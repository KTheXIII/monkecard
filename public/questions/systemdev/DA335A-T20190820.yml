version: '0.0.0'

datas:
  - content: |
      # Code Coverage: Vilka av följande påståenden är korrekta för code coverage?
    image: null
    options:
      - Code Coverage kan användas för att se vilka delar i din funktion/program som faktiskt körs. 
      - Code coverage är ett mått på hur mycket av din kod som exekveras beroende på vilka tester som körs. 
      - Ett program med hög code coverage är mer noggrant testat och har en lägre sannolikhet att innehålla programvarufel än ett program med låg kodtäckning. 
      - Det finns flera olika sätt att mäta Code coverage på, ett exempel är branch coverage. 
      - Path coverage innebär att man testar att varje distinkt väg genom koden exekveras minst en gång inom testet. 
      - 100 % code coverage innebär att allt i ditt program fungerar felfritt. 
    correct:
      - 0
      - 1
      - 2
      - 3
      - 4
    categories:
      - code-coverage
    source: 'DA335A-T20190820Q01'
  - content: |
      # Equivalence partitioning: Vad är korrekt gällande Equivalence partitioning?
    image: null
    options:
      - Equivalence partitioning kan endast användas när ett system är levererat och i bruk.
      - Equivalence partitioning kan användas när som helst under en testfas och kräver därmed ingen färdig produkt.
      - Equivalence partitioning innebär att en uppsättning indata delas in i grupper där medlemmarna i en grupp förväntas hanteras likvärdigt av systemet.
      - Equivalence partitioning kan endast användas en gång i testfasen, därefter bedöms den vara förbrukad.
      - Equivalence partitioning bygger på att testaren gör rimliga antaganden om hur programmet kommer att behandla indata.
      - Equivalence partitioning bygger på att testaren vet hur programmet kommer att behandla indata.
    correct:
      - 1
      - 2
      - 4
    categories:
      - equivalence-partitioning
    source: 'DA335A-T20190820Q02'
  - content: |
      # Boundary value analysis: Vilka påståenden är sanna om Boundary value analysis?
    image: null
    options:
      - 'När man använder Boundary value analysis bör man endast ha med ”valid values”.'
      - 'Man väljer ett värde från varje "grupp"'
      - 'Denna teknik kan tillämpas på alla nivåer av tester: unit-, integration- och systemnivå'
      - 'Hjälper testaren att välja de mest effektiva värdena från värdeintervall.'
      - 'Metoden innebär att man skapar tre testfall för varje gränsvärde.'
      - 'Denna metod hjälper testaren att avgöra gränsfall (boundary cases) där det är osäkert om resultatet är rätt eller fel.'
    correct:
      - 2
      - 3
      - 4
    categories:
      - boundary-value-analysis
    source: 'DA335A-T20190820Q03'
  - content: |
      # Granskning: Vilka av följande påståenden om granskning är sanna?
    image: null
    options:
      - Granskning är en form av .sk. ”Statisk testning”
      - Granskning hittar alltid fler buggar än dynamisk testning
      - I en sk ”Walkthrough” får inte författaren presentera sitt alster och man använde checklistor för att förbättra granskningsresultatet
      - Om man ber en kompis kolla igenom ens kod, så är detta en form av granskning
      - ”Desk Checking” innebär att man granskar hur skrivborden är anpassade för programutveckling
      - ”Inspektion” är en mer formell typ av granskning än ”Walkthrough”
    correct:
      - 0
      - 3
      - 5
    categories:
      - granskning
    source: 'DA335A-T20190820Q04'
  - content: |
      # Testning: Varför är det viktigt med integrationstestning? Vilka av följande påstående är korrekta??
    image: null
    options:
      - Integrationstest är ett sätt att verifiera att Unit-testerna är korrekt utförda
      - Integrationstester används för att verifiera att det testade systemet kan integreras mot andra system i det omgivande nätverket.
      - Integrationstest används för att verifiera att moduler är väl integrerade och är ett sätt att mäta hur modulerna beter sig sedan de har satts samman till en större enhet.
      - Integrationstest är ett sätt att mäta hur väl systemet har delats upp i olika moduler.
      - Integrationstest är ett bra sätt att hitta designfel
      - Integrationstest kräver ofta att man har en bra förståelse av hur systemet är uppdelat i olika moduler.
    correct:
      - 2
      - 5
    categories:
      - testing
    source: 'DA335A-T20190820Q05'
  - content: |
      # Kravhantering: Vad är korrekta påståenden om användningsfall/use cases?
    image: null
    options:
      - Ett scenario beskriver all funktionalitet i ett användningsfallsdiagram.
      - Med detaljerade användningsfallsbeskrivningar (av den typ som beskrivs i RUP) så kan även de icke-funktionella kraven för ett system beskrivas i dessa.
      - En aktör kan vara en person som interagerar med systemet men kan också representera ett annat system.
      - Utförliga scenarion eller användningsfallsbeskrivningar kan användas som testfall.
      - Begreppet extend används för att beskriva hur ett användningsfall eventuellt omfattar funktionalitet från ett annat användningsfall. 
      - Användningsfall beskriver vad ett system ska göra men inte hur detta utförs i kod.
    correct:
      - 2
      - 3
      - 4
      - 5
    categories:
      - kravhantering 
    source: 'DA335A-T20190820Q06'
  - content: |
      # Kravhantering: Vad är korrekta påståenden om kravinsamling?
    image: null
    options:
      - Kravinsamling bör bedrivas som en iterativ process.
      - Stängda intervjuer ökar risken för att man missar krav i förhållande till öppna intervjuer.
      - Att studera instruktioner för arbetsuppgifter är en tideffektiv metod för att få en bra uppfattning om hur arbetet utförs.
      - När man arbetar med olika synvinklar för krav så är det risk att samma krav uttrycks på flera olika sätt. 
      - Viss domänkunskap behövs för att avgöra om kraven är kompletta.
      - Kravinsamling inriktar sig främst på funktionella krav. 
    correct:
      - 0
      - 1
      - 3
      - 4
    categories:
      - kravhantering 
    source: 'DA335A-T20190820Q07'
  - content: |
      # Metrics: Vilka påståenden om olika metrics är korrekta?
    image: null
    options:
      - Coupling som uppstår för att två kod-moduler använder varandras variabler är bättre än coupling som uppstår för att funktioner anropas mellan kod-modulerna.
      - Begreppen slice, data token och data slice används när vi försöker mäta cohesion.
      - Cohesion och coupling är två metrics som kan användas för både objektorienterad och procedurel kod.
      - McCabes Cyclomatic Complexity kan bland annat användas för att visa på hur komplext nästlade satserna i koden är. 
      - Halstead Complexity Metrics mäter programlängd som en indirekt metric.
      - Halstead Complexity Metrics kan också användas för att mäta hur nästlad koden är.
    correct:
      - 1
      - 2
      - 3
      - 4
    categories:
      - metrics
    source: 'DA335A-T20190820Q08'
  - content: |
      # Software Engineering: Vad är korrekta påståenden gällande diagrammet nedan?
    image:
      source: './questions/systemdev/images/reliability-curve-of-software.jpg'
    options:
      - Software Engineering syftar till att minska avståndet mellan ”spikarna” markerade med 1 i diagrammet.
      - I punkt 2 så har mjukvaran själv eller något i mjukvarans omgivning förändrats. 
      - Kurvan markerad med 4 visar en kurva för mjukvara med bra kvalitet.
      - Diagrammet visar hur fel uppstår under utveckling av den första versionen av mjukvaran.
      - Diagrammet är endast tillämpbart på mjukvara som utvecklats med iterativa processer.
      - För ett legacysystem så är avståndet mellan kurvan markerad med 3 och kurvan markerad med 4 sannolikt kort.
    correct:
      - 2
    categories:
      - software-engineering
    source: 'DA335A-T20190820Q09'
  - content: |
      # Agila processmodeller: Vilka alternativ nedan är exempel på agila principer?
      (Engelsk och svensk text finns för varje alternativ. Den engelska texten är att betrakta som original. Observera att vissa uttryck är svåra att översätta till svenska med helt oförändrad innebörd.)
    image: null
    options:
      - >-
        Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage. 

        Välkomna ändrade krav, även sent i utvecklingen. Agila processer använder ändringar för att ge kunden en fördel i konkurrensen.
      - >-
        Simplicity - the art of maximizing the amount of work not done--is essential.

        Enkelhet – konsten att maximera mängden arbete som inte utförs – är essentiell. 
      - >-
        The best architectures, requirements, and designs emerge from self-organizing teams.

        Den bästa arkitekturen, kraven och designen uppstår i själv-organiserande grupper. 
      - >-
        Business people and developers work best separated from each other so that development isn’t interrupted. 

        Affärs-folk och utvecklare arbetar bäst åtskilda så att utvecklingen inte störs. 
      - >-
        Working software is the primary measure of progress.

        Fungerande mjukvara är det huvudsakliga måttet på framsteg. 
      - >-
        Architecture and internal design matters less than the external view the user experience.

        Arkitektur och intern design är mindre viktigt än den externa vy som användaren upplever.
    correct:
      - 0
      - 1
      - 2
      - 4
    categories:
      - agila-processmodeller
    source: 'DA335A-T20190820Q10'
  - content: |
      # Processmodeller: Vad är korrekta påståenden om processmodeller och processer för mjukvaruutveckling?
    image: null
    options:
      - Iterativa processer är också alltid inkrementella.
      - Olika processmodeller kan användas för olika delar av ett projekt.
      - Att definiera en processmodell är inte lönsamt för en mindre organisation med färre än 10 personer. 
      - Inkrementella processer uppstod och argumenterades för i samband med att begreppet agila processer etablerades runt millennieskiftet.
      - Det är viktigt att skilja på processmodellen man använder och processen man använder.
      - V-modellen beskriver iterativa processers flöde mellan krav och test. 
    correct:
      - 1
      - 4
    categories:
      - processmodeller
    source: 'DA335A-T20190820Q11'
  - content: |
      # Processmodeller: Vad är korrekta påståenden om evolutionära processer och processmodeller?
    image: null
    options:
      - Evolutionära processmodeller är inte iterativa.
      - Spiralmodellen kan betraktas som en evolutionär process-modell.
      - Evolutionära processer tillämpar en top-down-strategi.
      - Evolutionära processmodeller fungerar inte bra om kraven är otydliga. 
      - En inkrementell process med multipla releaser kan fungera som en evolutionär process.
      - Evolutionära processer kan användas tillsammans med prototyping (som en processmodell inom SE).
    correct:
      - 1
      - 2
      - 4
      - 5
    categories:
      - processmodeller
    source: 'DA335A-T20190820Q12'

# DA335A-T20190820Q13
# DA335A-T20190820Q14
# DA335A-T20190820Q15
# The app can't handle these type of question

  - content: |
      # Equivalence partitioning 
      Ett program låter användaren mata in ett heltal, och programmet skriver sedan ut huruvida talet är positivt, negativt eller noll. Programmet ska testas enligt ”equivalence partitioning”. Vilka av följande alternativ innehåller data som kan antas tillhöra samma ”equivalence group”?
    image: null
    options:
      - ”minus sju”, ”noll”, ”fyra” 
      - -13, 0, 48 
      - 0, 3.14, 2147483647
      - 47, 13, 991 
      - -4, -13, -48.9 
      - 1, 2, 3 
    correct:
      - 0
      - 3
      - 5
    categories:
      - equivalence-partitioning 
    source: 'DA335A-T20190820Q16'

# The rest the app can't handle